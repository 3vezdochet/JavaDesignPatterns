Одиночка — это порождающий паттерн проектирования,
который гарантирует, что у класса есть только один
экземпляр, и предоставляет к нему глобальную точку
доступа.

Любят холеварить что синглтон антипаттерн, так как:
Одиночка решает сразу две проблемы связанные с порождением и поведением (нарушая принцип
единственной ответственности класса).

Да, решает две проблемы. Нет, не плохой паттерн, а один из самых распространенных.
В языках Scala и Kotlin для создания синглтонов используется конструкция Object

1. Синглтон гарантирует наличие единственного экземпляра класса.
   Чаще всего это полезно для доступа к какому-то общему
   ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто
   глобальная переменная, через которую можно достучаться
   к определённому объекту. Глобальные переменные не
   защищены от записи, поэтому любой код может подменять
   их значения без вашего ведома.

Все реализации одиночки сводятся к тому, чтобы скрыть
конструктор по умолчанию и создать публичный
статический метод, который и будет контролировать
жизненный цикл объекта-одиночки.

Принято, что статисческое поле, хранящее ссылку на переменную имеет название instance<
а статический метод getInstance().
Все к этому привыкли, так что используйте только такие названия.
Гадать что имел ввиду автор люди не любях и не хотят!

см. diagram.png

Плюсы:

- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
- Реализует отложенную инициализацию объекта-одиночки.

Минусы (с некоторыми я не согласен):

- Нарушает принцип единственной ответственности класса.
- Требует постоянного создания Mock-объектов при юниттестирования.
- Маскирует плохой дизайн.
- Проблемы мультипоточности.

В книге Olaf Musch приведены несколько спсобов и примеров создания потоко-безопасных
Синглтонов. Возможно вам пригодиться это при выполнении ЛР3.
Сущесвует несколько способов создания потоко-безопасных синглотов, в завивисимости от ситуации.